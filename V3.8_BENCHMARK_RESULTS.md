# Zen v3.8.0 Benchmark Results

## Executive Summary

Zen v3.8.0 implements V8 engine-specific optimizations:
1. **Hidden Class Optimization** - Pre-allocate all properties
2. **Monomorphic Code Paths** - Separate helper functions

**Bundle Size**: 2.49 KB gzipped (+5.1% vs v3.7) / 2.21 KB brotli (+5.7%)
**Performance**: Mixed results, +10-44% in some scenarios

---

## Full Benchmark Results

### Version Tracking: Unchanged Dependencies

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Diamond pattern - unchanged base | 740,901 ops/sec | 626,060 ops/sec | -15% ⚠️ |
| Deep chain (10 layers) - unchanged | 49,383 ops/sec | 45,198 ops/sec | -8% |

### Version Tracking: Changed Dependencies

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Diamond pattern - changed base | 1,107,931 ops/sec | 1,245,653 ops/sec | **+12%** ✅ |
| Deep chain (10 layers) - changed | 1,293 ops/sec | 1,683 ops/sec | **+30%** ✅ |

### Observer Slots: Subscription Changes

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Create and destroy computed | 2,180,431 ops/sec | 2,872,878 ops/sec | **+32%** ✅ |
| Dynamic dependencies | 8,400 ops/sec | 10,063 ops/sec | **+20%** ✅ |
| Multiple computeds sharing | 2,355 ops/sec | 2,469 ops/sec | +5% |

### Real-World Patterns

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Form validation | 4,374 ops/sec | 3,825 ops/sec | -13% ⚠️ |
| Shopping cart | 3,641 ops/sec | 5,255 ops/sec | **+44%** ✅ |

### Stress Tests

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Large graph (500 computed) | 70 ops/sec | 66 ops/sec | -6% |
| Rapid subscription changes | 4,794 ops/sec | 6,322 ops/sec | **+32%** ✅ |

### Basic Operations

| Test | v3.7.0 | v3.8.0 | Change |
|------|--------|--------|--------|
| Signal write (10k) | 10,178 ops/sec | 21,759 ops/sec | **+114%** ✅ |
| Signal read (10k) | 33,426 ops/sec | 34,582 ops/sec | +3% |
| Computed access | 2,854,427 ops/sec | 3,325,950 ops/sec | **+17%** ✅ |

---

## Performance Analysis

### Improvements ✅

1. **Create/destroy computed**: +32%
   - Hidden classes make allocation/deallocation more efficient
   - Monomorphic code paths reduce overhead

2. **Shopping cart**: +44%
   - Complex reactive graphs benefit from consistent object shapes
   - Better V8 optimization over time

3. **Signal write**: +114%
   - Pre-allocated properties speed up property assignments
   - Consistent shape → faster property access

4. **Dynamic dependencies**: +20%
   - Subscription changes benefit from O(1) cleanup + hidden classes

5. **Computed access**: +17%
   - Monomorphic helper functions improve inline caching

### Regressions ⚠️

1. **Diamond pattern (unchanged)**: -15%
   - Initialization overhead: setting properties to undefined
   - Fast-path version check doesn't offset initialization cost in this scenario

2. **Form validation**: -13%
   - Similar initialization overhead issue
   - Multiple small computed values → initialization dominates

### Mixed Results

The results show a trade-off pattern:
- **Hot paths benefit**: Frequently accessed code benefits from JIT optimization
- **Cold paths regress**: One-time initialization overhead dominates
- **Long-running apps win**: More time for V8 to optimize

---

## Bundle Size Comparison

| Metric | v3.7.0 | v3.8.0 | Change |
|--------|--------|--------|--------|
| **Raw (ESM)** | - | 7.52 KB | - |
| **Gzipped** | 2.37 KB | 2.49 KB | +0.12 KB (+5.1%) |
| **Brotli** | 2.09 KB | 2.21 KB | +0.12 KB (+5.7%) |

**Analysis**: Small size increase for:
1. Pre-allocation code in constructors
2. Monomorphic helper functions

**Worth it?**: Trade-off depends on use case:
- ✅ Long-running SPAs: JIT optimization benefits over time
- ⚠️ Short scripts: Initialization overhead dominates
- ✅ Hot paths: Monomorphic code wins
- ⚠️ Bundle size critical: +120 bytes might matter

---

## Recommendations

### Upgrade to v3.8 if:
- ✅ You have long-running applications (SPAs, dashboards)
- ✅ You have complex reactive graphs (100+ signals/computed)
- ✅ You have frequent create/destroy patterns
- ✅ Performance predictability > absolute speed

### Stay on v3.7 if:
- ⚠️ Bundle size is critical (every byte counts)
- ⚠️ Short-lived scripts (CLIs, one-off operations)
- ⚠️ Simple apps with few signals

---

## Technical Details

### Hidden Class Optimization

**Before v3.8**:
```typescript
const signal = Object.create(zenProto);
signal._kind = 'zen';           // Hidden class A
signal._value = initialValue;   // Hidden class B
// Properties added on-demand → different hidden classes!
```

**After v3.8**:
```typescript
const signal = Object.create(zenProto);
signal._kind = 'zen';
signal._value = initialValue;
signal._listeners = undefined;         // Pre-allocate!
signal._pendingOldValue = undefined;
signal._computedListeners = undefined;
signal._computedSlots = undefined;
signal._version = 0;
// Same hidden class for all signals! → monomorphic property access
```

### Monomorphic Code Paths

**Before v3.8**:
```typescript
const zenProto = {
  get value() {
    if (currentListener) { /* tracking */ }
    return this._value;
  }
};
// Polymorphic: handles both zen AND computed
```

**After v3.8**:
```typescript
function readZenValue(signal: ZenCore<any>): any {
  if (currentListener) { /* tracking */ }
  return signal._value;
}

const zenProto = {
  get value() { return readZenValue(this); }
};
// Monomorphic: only handles zen signals!
```

---

## Conclusion

Zen v3.8.0 trades +120 bytes for better V8 optimization characteristics:

**Best for**: Long-running apps, complex reactive graphs, hot paths
**Not ideal for**: Bundle size critical, short scripts, simple apps

**Overall verdict**: ✅ Upgrade recommended for most SPAs and complex applications

The performance improvements in hot paths (+17% to +114%) and better predictability outweigh the small regressions in cold paths and bundle size increase.

---

## Next Steps

See `ADVANCED_OPTIMIZATIONS_RESEARCH_2025.md` for future optimization opportunities:
- v4.0: Compiler-driven optimizations (30-40% gain)
- v5.0: WebAssembly integration (20-50% gain)
- v6.0+: Parallel computation
